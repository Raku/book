=head0 Subs and Signatures

X<subroutine>
X<arguments>
X<signature>
X<return value>

A I<subroutine> is a piece of code that performs a specific task. It may
operate on provided data, also known as I<arguments>.  It may also produce some
result, which is known as a return value.  The I<signature> of a subroutine is
a description of the arguments it takes and the return value it produces.

You have already seen some simple subroutines in the first chapter.  The second
chapter described operators.  In a sense, these are also subroutines that Perl
6 parses in interesting ways.  However, these just scratch the surface of
what's possible.

=head1 Declaring A Subroutine

X<subroutines; declaration>

A subroutine declaration consists of several parts, some of which are
optional. First, there is the subroutine declarator, C<sub>, which
signifies that you are starting a subroutine declaration. The declarator
may be followed by a name and/or a signature, each optional. Finally, a
block of code enclosed in curly braces that is the body of the
subroutine. It is this block of code that will be executed each time the
subroutine is called.

Below is a simple example subroutine declaration:

=begin programlisting

 sub panic() {
     say "Oh no! Something has gone most terribly wrong!";
 }

=end programlisting

X<subroutines; scoping>
X<scoping; subroutines>

By default, subroutines are lexically scoped, just like any variable
declared with C<my>. In the absence of any code indicating otherwise, a
subroutine may only be called within the scope it was declared. To make
the subroutine more widely available, the scoping declarator C<our> may
be used to also place the subroutine within the symbol table of the
current package.

=begin programlisting

 {
     our sub eat() {
         say "om nom nom";
     }

     sub drink() {
         say "glug glug";
     }
 }

 eat();    # om nom nom
 drink();  # fails, can't drink outside of the block

=end programlisting

X<anonymous subroutines>
X<subroutines; anonymous>
X<subroutines; first-class>
X<first-class subroutines>

Perl 6 subroutines are objects. You can pass them around and store them
in data structures just like you can do with any other piece of data.
Programming language designers often call these I<first-class subroutines>,
because they behave like other built-in data structures.  This offers 
tremendous potential. For example, to make a little ASCII art dancing 
figure, you could build up a hash where the keys are names of the dance
moves, and the values are anonymous subroutines:

=begin programlisting

 my $dance = '';
 my %moves =
     hands-over-head => sub { $dance ~= '/o\ '   },
     bird-arms       => sub { $dance ~= '|/o\| ' },
     left            => sub { $dance ~= '>o '    },
     right           => sub { $dance ~= 'o< '    },
     arms-up         => sub { $dance ~= '\o/ '   };

 my @awesome-dance = <arms-up bird-arms right hands-over-head>;

 for @awesome-dance -> $move {
     %moves{$move}.();
 }

 say $dance;

=end programlisting

From the output of this program, you can observe that doing the YMCA dance in
ASCII art looks as bad as in real life.

=head1 Adding Signatures

X<parameter>
X<subroutines; signature>
X<signatures; subroutines>

A subroutine signature performs two roles. First, it declares the arguments callers
may or must pass to the subroutine. Second, it declares the variables in the
subroutine to which the arguments are bound. These variables are called
I<parameters>.  Perl 6 signatures go further; they
allow you to constrain the values of arguments and to extract specific
pieces of data structures.

=head2 The Basics

In its most simple form, a signature is a comma separated list of variable
names to which incoming arguments are bound.

=begin programlisting

 sub order-beer($type, $pints) {
     say ($pints == 1 ?? 'A pint' !! "$pints pints") ~ " of $type, please."
 }

 order-beer('Hobgoblin', 1);    # A pint of Hobgoblin, please.
 order-beer('Zlatý Bažant', 3); # 3 pints of Zlatý Bažant, please.

=end programlisting

The use of the term I<bound> instead of I<assigned> is significant. The
variables in your signature are read-only references to the passed
arguments. You cannot modify them within the subroutine. If this is too
limiting, then you have two different ways to relax this restriction.

Marking a parameter as C<is rw> means that you are allowed to modify the passed
argument.  If you modify that value, you modify the original in place.  If you
attempt to pass a literal or some other constant value for an C<rw> parameter,
binding of that signature will fail and the subroutine call will not occur.

=begin programlisting

 sub make-it-more-so($it is rw) {
     $it ~= substr($it, $it.chars - 1) x 5;
 }

 my $happy = "yay!";
 make-it-more-so($happy);
 say $happy;                # yay!!!!!!
 make-it-more-so("uh-oh");  # Fails; can't modify a constant

=end programlisting

If, instead, you want your own copy of the argument to work with inside the
subroutine--if you want to leave the original untouched--then mark the
parameter C<is copy>.

=begin programlisting

 sub say-it-one-higher($it is copy) {
     $it++;
     say $it;
 }

 my $unanswer = 41;
 say-it-one-higher($unanswer);  # 42
 say-it-one-higher(41);         # 42

=end programlisting

The extra verbosity of marking parameters as mutable may seem excessive, but
it's likely you won't use these modifiers often.  While certain languages
require you to mark parameters as C<rw> to emulate returning multiple result
from a single subroutine, Perl allows you to return multiple values directly.

=head2 Passing Arrays, Hashes and Code

Sigils on variables indicate their intended use.  In a signature, a variable's
sigil acts as a constraint on the type of argument passed.  The C<@>
sigil, for example, checks that the passed value is iterable.  Failing to pass
something that matches this constraint will cause the call to fail.

=begin programlisting

 sub shout-them(@words) {
     for @words -> $w {
         print uc("$w ");
     }
 }

 my @last_words = <do not want>;
 shout-them(@last_words);  # DO NOT WANT
 shout-them('help');       # Fails; a string is not iterable

=end programlisting

Similarly, the C<%> sigil implies that the caller must pass something that
allows associative indexing through the C<< <...> >> or C<{...}> operations.
The C<&> sigil requires that the caller pass something callable, such as an
anonymous subroutine. In that case, you may call the callable parameter without
having to use the C<&> sigil.

=begin programlisting

 sub do-it-lots(&it, $how-many-times) {
     for 1..$how-many-times {
         it();
     }
 }

 do-it-lots(sub { say "Eating a stroopwafel" }, 10);

=end programlisting

A scalar (the C<$> sigil) implies no constraints.  Anything may bind to it,
even if that anything could bind to one of the other sigils.

=head2 Interpolating Arrays and Hashes

Sometimes you want to fill positional arguments from an array. Instead of
writing C<eat(@food[0], @food[1], @food[2], ...)> and so on for every array
item, you can I<interpolate> them into the argument list by prepending a vertical
bar: C<eat(|@food)>.

Likewise, you can interpolate hashes into named arguments:

=begin programlisting

 my %user-preferences = from => 'Northern Sea';
 order-shrimps(3, |%user-preferences)

=end programlisting

=head2 Optional Parameters

=for author

Until now, the distinction between "arguments" and "parameters" has been clear.
Here's where it gets confusing.  We should use one consistently, or define the
distinction between the two clearly for readers (if they even need to know a
distinction) and use them precisely.

=end for

Sometimes parameters have sensible defaults values.  Sometimes, certain
arguments are unnecessary.  In these cases, it is nice to mark such parameters
as optional, so those calling the subroutine can choose whether to pass values.

Either assign a default value to the parameter in the signature or append a
question mark to the parameter's name:

=begin programlisting

 # with a default value
 sub order-steak($how = 'medium') {
     say "I'd like a steak, $how";
 }

 order-steak();
 order-steak('well done');

 # without a default value
 # TODO: come up with a good example

=end programlisting

=head2 Named Parameters

When a subroutine has many parameters, it is sometimes hard to remember their
respective order. When that happens, it is often easier to call them by name
instead:

=begin programlisting

 sub order-beer($type, $pints) {
     say ($pints == 1 ?? 'A pint' !! "$pints pints") ~ " of $type, please."
 }

 order-beer(type => 'Hobgoblin', pints => 1);
    # A pint of Hobgoblin, please.

 order-beer(pints => 3, type => 'Zlatý Bažant');
    # 3 pints of Zlatý Bažant, please.

=end programlisting

The names are those that appeared as parameter names in the signature.  When
you pass arguments by name, the order in which they appear does not matter.

You may also specify that an incoming argument may only fill a parameter by
name, never by position; precede the name of the parameter with a colon:

=begin programlisting

 sub order-shrimps($count, :$from = 'North Sea') {
     say "I'd like $count pieces of shrimp from the $from, please";
 }

 order-shrimps(6);                       # takes the default value 'North Sea'
 order-shrimps(4, from => 'Atlantic Ocean');
 order-shrimps(22, 'Mediterranean Sea'); # not allowed, :$from is named only

=end programlisting

Named parameters are optional by default.  Adding a C<!> at the end makes one
mandatory.

=begin programlisting

 sub design-ice-cream-mixture(:$name!, $base = 'Vanilla', @mixins) {
    say "Creating a new recipe named $name!"
 }

 design-ice-cream-mixture(name => 'Plain');
 design-ice-cream-mixture(base => 'Strawberry chip'); # missing $name

=end programlisting

=head3 Renaming Parameters

Argument names do not necessarily have to correspond exactly to parameter names within the subroutine; you may remap them as you desire:

=begin programlisting

 sub announce-time(:dinner($supper) = '8pm') {
     say "We eat dinner at $supper";
 }

 announce-time(dinner => '9pm');      # We eat dinner at 9pm

=end programlisting

Parameters can also have multiple names. If the users are both British and
Americans, one might write:

=begin programlisting

 sub paint-rectangle(
         :$x = 0,
         :$y = 0,
         :$width = 100,
         :$height = 50,
         :color(:colour($c))) {
 
    # print a piece of SVG that reprents a rectangle
    say qq[<rect x="$x" y="$y" width="$width" height="$height"
                 style="fill: $c" />]
 }
 
 # both calls work the same
 paint-rectangle :color<Blue>;
 paint-rectangle :colour<Blue>;

 # and of course you can still fill the other options
 paint-rectangle :width(30), :height(10), :colour<Blue>;


=end programlisting

C<:color(:colour($c))>  or C<:color(:$colour))>.

=head3 Alternative Named Argument Syntaxes

=for author

This section is confusing.  I've tried to clarify.

=end for

Named arguments are actually C<Pair>s.  There are multiple ways to write
C<Pair>s; each of them provides a different mechanism for quoting.  The
difference between the approaches is primarily one of clarity.  This allows you
to pass arguments in multiple ways.  These three calls all mean the same thing:

=begin programlisting

 announce-time(dinner => '9pm');
 announce-time(:dinner('9pm'));
 announce-time(:dinner<9pm>);

=end programlisting

If you're only passing a boolean value, you don't even need the value portion
of the pair:

=begin programlisting

 toggle-blender( :enabled); # enables  the blender
 toggle-blender(:!enabled); # disables the blender

=end programlisting

A named argument of the form C<:name> with no value has an implicit value of
C<Bool::True>.  The negated form of this, C<:!name>, has an implicit value of
C<Bool::False>.

If you use a variable to create a pair, you can reuse the variable name as the
key of the pair.

=begin programlisting

 my $dinner = '9pm';
 announce-dinner :$dinner;  # same as dinner => $dinner;

=end programlisting

The following table lists possible C<Pair> forms and their meanings:

    Shorthand           Long form                   Description

    :allowed            allowed => Bool::True       Boolean flag
    :!allowed           allowed => Bool::False      Boolean flag
    :bev<tea coffee>    bev => ('tee', 'coffee')    List
    :times[1, 3]        times => [1, 3]             Array
    :hash{ a => 2}      hash => { a => 2}           Hash
    :$var               var => $var                 Scalar variable
    :@var               var => @var                 Array variable
    :%var               var => %var                 Hash variable

You can use all of these forms in any context where you can use a C<Pair>
object, for example when populating a hash:

=begin programlisting

 # TODO: better example
 my $black = 12;
 my %color-popularities = :$black, :blue(8),
                          red => 18, :white<0>;

=end programlisting

Finally, to pass an existing C<Pair> object to a subroutine by position, not
name, either put it in parentheses (like C<(:$thing)>), or use the C<< => >>
operator with a quoted string on the left-hand side: C<< "thing" => $thing >>.

=head2 Slurpy Parameters

In an earlier example the function C<shout-it> accepted an array argument.
There is no need to the user to build an array and pass that to the function:

=begin programlisting

 sub shout-them(*@words) {
     for @words -> $w {
         print uc("$w ");
     }
 }

 # now you can pass items
 shout-them('go')            # GO
 shout-them('go', 'home');   # GO HOME

 my @words = ('go', 'home');
 shout-them(@words);         # still works

=end programlisting

X<slurpy>

An asterisk C<*> preceding an array parameter marks it as I<slurpy>. It stores
all remaining unbound positional arguments in an array.  Likewise C<*%hash>
slurps all the remaining unbound named arguments into a hash.

Slurpy arrays and hashes allow you to pass all positional and named arguments
to another routine, for example:

=begin programlisting

 sub debug-wrapper(&code, *@positional, *%named) {
     warn "Calling '&code.name()' with arguments "
          ~ "@positional.perl(), %named.perl()\n";
     code(|@positional, %named);
     warn "... back from '&code.name()'\n";
 }

 debug-wrapper(&order-shrimps, 4, from => 'Atlantic Ocean');

=end programlisting

=head1 Returning Results

Subroutines can also return values.  The ASCII art dancing example from earlier
in this chapter is prettier and simpler when its anonymous subroutines return
values.  Instead of modifying a variable inside the subroutine, these
subroutines now each return a new string for their callers to use:

=begin programlisting

 my %moves =
     hands-over-head => sub { return '/o\ '   },
     bird-arms       => sub { return '|/o\| ' },
     left            => sub { return '>o '    },
     right           => sub { return 'o< '    },
     arms-up         => sub { return '\o/ '   };

 my @awesome-dance = <arms-up bird-arms right hands-over-head>;
 for @awesome-dance -> $move {
     print %moves{$move}.();
 }
 print "\n";

=end programlisting

A Perl subroutine can return multiple values:

=begin programlisting

 sub menu {
     if rand < 0.5 {
         return ('fish', 'white wine')
     } else {
         return ('steak', 'read wine');
     }
 }

 my ($food, $beverage) = menu();

=end programlisting

X<return>

Even C<return> itself is not necessary.  If you exclude it, Perl will return
the expression produced by the last statement run inside the subroutine.  This
simplifies the example code:

=begin programlisting

 sub menu {
     if rand < 0.5 {
         'fish', 'white wine'
     } else {
         'steak', 'read wine';
     }
 }

 my ($food, $beverage) = menu();

=end programlisting

X<return; implicit>

Be wary of relying on this, however: sometimes the flow of control within a
subroutine is sufficiently complex that adding explicit C<return> clarifies.
As a general rule, only the simplest subroutines benefit from implicit
C<return>.

C<return> has the additional effect of immediately exiting the subroutine:

=begin programlisting

 sub create-world(*%characteristics) {
    my $world = World.new(%characteristics);
    return $world if %characteristics<temporary>;

    save-world($world);
 }

=end programlisting

... and you'd better not misplace your new C<$world> if it's temporary, as it's
the only one you're going to get.


=head1 Working With Types

Many subroutines can not meaningfully work with arbitrary parameters,
but require that the parameters support certain methods.

If that is the case, it makes sense to restrict the parameters in a way that
only supported values can be passed as arguments. That way an error is raised
early on (at the time of calling the routine) when a "bad" value is passed.

=head2 Basic Types

X<constraint; type>
X<parameter type constraint>

You can restrict the possible values that a subroutine accepts by putting a
type name in front of a parameter. For example a subroutine that does numeric
calculation with its parameters could restrict the parameters to the type
C<Numeric>:

=begin programlisting

    sub mean(Numeric $a, Numeric $b) {
        return ($a + $b) / 2;
    }

    say mean 2.5, 1.5;
    say mean 'some', 'strings';

=end programlisting

Which produces this output:

=begin screen

 2
 Nominal type check failed for parameter '$a'; expected Numeric but got Str instead

=end screen

If multiple parameters have a type constraint, each argument has to fulfill
the type constraint of the parameter it is bound to.


=head2 Adding Constraints

X<constraint>

Sometimes a type name is not enough to sufficiently describe the parameters of
a subroutine. In this case an additional I<constraint> can be added to the
parameter with a C<where> block:

=begin programlisting

 sub circle-radius-from-area(Numeric $area where { $area >= 0) {
     ($area / pi).sqrt
 }
 say circle-radius-from-area(3);    # OK
 say circle-radius-from-area(-3);   # Error

=end programlisting

Since the calculation can only be carried out for non-negative values of the
area, the parameter name is followed by a C<where> block that returns C<True>
for non-negative values. If such an additional constraint returns a false
value, the type check at the time of the routine call fails.

=for author

TODO: explain C<where $value> smart matching constraints
once we talk about smart matching somewhere

=end for

=head1 Captures

X<captures>
X<Capture>

In one sense, a signature is a collection of parameters. Captures fill the same
niche as arguments. Just as you rarely think of a signature as a whole--instead
focusing on individual parameters--you rarely have to think about captures.
When you do, Perl 6 allows you to manipulate captures directly. This can be
useful.

Captures have both positional and named parts, which act like lists and a
hashes respectively. The list-like part contains the positional parameters and
the hash-like part contains the named parameters.

=head2 Creating And Using A Capture


=head2 Captures In Signatures


=head1 Unpacking

Sometimes you need to work with only part of an array or a hash.  You can do
that with ordinary slicing access, or you can use signature binding:

=begin programlisting

  sub first-is-largest(@a) {
      my $first = @a.shift;
      # TODO: either explain junctions, or find a
      # concise way to write without them
      return $first >= all(@a);
  }

  # same thing:
  sub first-is-largest(@a) {
      my :($first, *@rest) ::= \(|@a)
      return $first >= all(@rest);
  }

=end programlisting

The signature binding approach might seem clumsy, but when you use it in the
main signature of a subroutine, you get tremendous power:

=begin programlisting

  sub first-is-largest([$first, *@rest]) {
      return $first >= all(@rest);
  }

=end programlisting

X<unpacking>
X<signature unpacking>
X<subsignature>

The brackets in the signature tell the compiler to expect a list-like argument.
Instead of binding to an array parameter, it instead gets I<unpacked> into
several parameters--in this case, a scalar for the first element and an array
for the rest.  This I<subsignature> also acts as a constraint on the array
parameter: the signature binding will fail unless the list in the capture
contains at least one item.

Likewise you can unpack a hash by using C<%(...)> instead of square brackets.
You must access named parameters instead of positional.

=for author

Is this a little too cute?

=end for

=begin programlisting

 sub create-world(%{:temporary, *%characteristics}) {
    my $world = World.new(%characteristics);
    return $world if :temporary;

    save-world($world);
 }

=end programlisting

# TODO: come up with a good example

# TODO: generic object unpacking

=head1 Introspection


=for editor vim: se spell
