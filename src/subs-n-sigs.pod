=head0 Subroutines and Signatures

Z<sec:subs>
X<subroutine>
X<arguments>
X<signature>
X<return value>
X<return type>

A I<subroutine> is a piece of code that performs a specific task. It may
operate on provided data (I<arguments>) and may produce results (I<return
values>).  The I<signature> of a subroutine is a description of any arguments
it takes and any return values it produces.

Chapter 2 demonstrated simple subroutines.  In a sense, the operators
described in chapter 3 are also subroutines that Perl 6 parses in
interesting ways.  However, they only scratch the surface of what's possible.

=head1 Declaring a Subroutine

X<subroutines, declaration>

A subroutine declaration consists of several parts.  First, the subroutine
declarator C<sub> indicates that you are starting a subroutine declaration.
Next comes an optional name and an optional signature.  The body of the
subroutine
follows as a block of code enclosed in curly braces.  This is what will execute
every time the subroutine is called.

For example, in:

=begin programlisting

    sub panic() {
        say "Oh no! Something has gone most terribly wrong!";
    }

=end programlisting

... the name of the sub is C<panic>.  Its signature is empty.  Its body
consists of a single C<say> statement.

X<subroutines, scoping>
X<scoping, subroutines>

=for author

Link to exporting section.  Also, the description of scoping may be subtle
here.

=end for

By default, subroutines are lexically scoped, just like any variable declared
with C<my>. This means that a subroutine may only be called within the scope in
which it was declared.  Use the scope declarator C<our> to make the subroutine
available within the current package:

=begin programlisting

    {
        our sub eat() {
            say "om nom nom";
        }

        sub drink() {
            say "glug glug";
        }
    }

    eat();    # om nom nom
    drink();  # fails, can't drink outside of the block

=end programlisting

C<our> also makes subroutines visible from the outside of a package or module:

=begin programlisting

    module EatAndDrink {
         our sub eat() {
             say "om nom nom";
         }

         sub drink() {
             say "glug glug";
         }
    }
    EatAndDrink::eat();    # om nom nom
    EatAndDrink::drink();  # fails, not declared with "our"

=end programlisting

# TODO: elaborate

You may also export a subroutine to make it available to another
scope.

X<anonymous subroutines>
X<subroutines, anonymous>
X<subroutines, first-class>
X<first-class subroutines>

Perl 6 subroutines are objects. You can pass them around and store them in data
structures just as you can do with any other piece of data.  Programming
language designers often call these I<first-class subroutines>; they are as
fundamental to the language as hashes or arrays are.

First-class subroutines can help you solve complex problems.  For example, to
make a little ASCII art dancing figure, you could build up a hash where the
keys are names of the dance moves, and the values are anonymous subroutines.
Assume that users should be able to enter a list of moves (perhaps on a dance
pad or other exotic input device).  How can you maintain a variable list of
custom behaviors, allow user input, and restrict that input to a safe set of
behaviors?

TODO this example doesn't seem like a good one for first-class subs.

=begin programlisting

    my %moves =
        hands-over-head => sub { say '/o\ '   },
        bird-arms       => sub { say '|/o\| ' },
        left            => sub { say '>o '    },
        right           => sub { say 'o< '    },
        arms-up         => sub { say '\o/ '   };

    my @awesome-dance = <arms-up bird-arms right hands-over-head>;

    for @awesome-dance -> $move {
        %moves{$move}.();
    }

    # outputs:
    #              \o/
    #              |/o\|
    #              o<
    #              /o\

=end programlisting

From the output of this program, you can observe that doing the YMCA dance in
ASCII art looks just as bad as in real life.

=head1 Adding Signatures

Z<sec:signatures>
X<parameter>
X<subroutines, signature>
X<signatures, subroutines>

A subroutine signature performs two tasks. First, it declares the arguments
which callers may or must pass to the subroutine. Second, it declares the
variables in the subroutine to which the arguments are bound. These variables
are called I<parameters>N<In this book, we will use the traditional convention
of using the term I<parameters> when referring to the variables in a
subroutine's signature and I<arguments> when referring to the values actually
passed when a subroutine is called. Though, for the most part, you can consider
these terms interchangeable.> Perl 6 signatures go further; they allow you to
constrain the type, value, and "definedness" of its arguments and match against
and extract parts of complex data structures. Additionally, they also allow you
to explicitly specify the return type of a subroutine.

=head2 The Basics

In its simplest form, a signature is a comma separated list of variable names
to which to bind incoming arguments.

=begin programlisting

    sub order-beer($type, $pints) {
        say ($pints == 1 ?? 'A pint' !! "$pints pints") ~ " of $type, please."
    }

    order-beer('Hobgoblin', 1);    # A pint of Hobgoblin, please.
    order-beer('Zlatý Bažant', 3); # 3 pints of Zlatý Bažant, please.

=end programlisting

The use of the term I<bound> instead of I<assigned> is significant here. In
Perl 6, the variables in a subroutine's signature are read-only references to
the passed arguments by default. This means that you B<can not> modify them
from inside the subroutine.

If read-only binding is too limiting, you can relax this restriction by
applying the C<is rw> ("rw" being short for I<read/write>) trait to a
parameter. This allows you to modify the argument inside the subroutine. Use
caution as this B<will> alter the original object passed. If you attempt to
pass a literal value, a constant, or some other type of immutable
objectN<An I<immutable> object is an object whose state cannot be changed after
it has been created. By contrast, a I<mutable> object may be changed after
being created.> to a parameter that has the C<is rw> trait, the binding will
fail at the time of the call and throw an exception:

=begin programlisting

    sub make-it-more-so($it is rw) {
        $it ~= substr($it, $it.chars - 1) x 5;
    }

    my $happy = "yay!";
    make-it-more-so($happy);
    say $happy;                # yay!!!!!!
    make-it-more-so("uh-oh");  # Fails; can't modify a constant

=end programlisting

If, instead, you want a local copy of the argument to work with inside the
subroutine - leaving the caller's variable untouched - use the C<is copy>
trait:

=begin programlisting

    sub say-it-one-higher($it is copy) {
        $it++;
        say $it;
    }

    my $unanswer = 41;
    say-it-one-higher($unanswer);  # 42
    say-it-one-higher(41);         # 42

=end programlisting

In other programming languages, such as C/C++ and Scheme, this evaluation
strategy is known as I<pass-by-value>. When using the C<is copy> trait, only
the local copy is assigned; any arguments passed to the subroutine remain
unchanged in the caller's scope.

The extra verbosity of marking parameters as mutable or immutable may seem
excessive at first, but as an average user, it's unlikely that you'll need to
use these traits often.

=head2 Passing Arrays, Hashes and Code

A variable's sigil indicates its intended use. In a signature, a variable's
sigil also acts as a constraint on the type of argument that can be passed.
For example, the C<@> sigil checks that the object passed does the
C<Positional> role (a role which includes types like C<Array> and C<List>).
Failing to pass something that matches this constraint will cause the call to
fail:

=begin programlisting

    sub shout-them(@words) {
        for @words -> $w {
            print uc("$w ");
        }
    }

    my @last_words = <do not want>;

    shout-them(@last_words);  # DO NOT WANT
    shout-them('help');       # Fails; a string is not Positional

=end programlisting

Similarly, the C<%> sigil implies that the caller must pass an object that does
the C<Associative> role; that is, something which allows indexing through
C<< <...> >> or C<{...}>. The C<&> sigil requires the caller to pass an object
that does the C<Callable> role such as an anonymous subroutine. In that case,
you may also call the callable parameter without the C<&> sigil:

=begin programlisting

    sub do-it-lots(&it, $how-many-times) {
        for 1..$how-many-times {
            it();
        }
    }

    do-it-lots(sub { say "Eating a stroopwafel" }, 10);

=end programlisting

A scalar uses the C<$> sigil and implies no constraints. Anything may bind to
it, even if it could also bind to an object with one of the other sigils.

=head2 Interpolating Arrays and Hashes

Sometimes you want to fill positional arguments from an array. Instead of
writing C<eat(@food[0], @food[1], @food[2], ...)> and so on, you can
I<flatten> them into the argument list by prepending it with the vertical bar
or "pipe" character (C<|>): C<eat(|@food)>.

Likewise, you can interpolate hashes into named arguments:

=begin programlisting

    sub order-shrimps($count, :$from) {
        say "I'd like $count pieces of shrimp from the $from, please";
    }

    my %user-preferences = from => 'Northern Sea';

    order-shrimps(3, |%user-preferences);
    # I'd like 3 pieces of shrimp from the Northern Sea, please

=end programlisting

=head2 Optional Parameters

Some parameters may have sensible default values, or may not be required for the
sub-routine to operate; they merely add some extra, optional, configurability.
In this case, it is possible to mark the parameter as optional. Those calling the
subroutine can then choose whether or not to supply an argument.

To make a parameter optional, either assign a default value to the parameter in
the signature:

=begin programlisting

    sub order-steak($how = 'medium') {
        say "I'd like a steak, $how";
    }

    order-steak();
    order-steak('well done');

=end programlisting

or append a question mark to the parameter's name:

=begin programlisting

    sub order-burger($type, $side?) {
       say "I'd like a $type burger" ~
           ( defined($side) ?? " with a side of $side" !! "" );
    }

    order-burger("triple bacon", "deep fried onion rings");

=end programlisting

If no argument is passed, an undefined value will be bound to the parameter. As
demonstrated, the C<defined(...)> function can be used to check if there is a
value or not.

=head2 Required Parameters

Positional parameters are always required by default. However, you can
explicitly specify that a parameter is required by appending a C<!> to it:

=begin programlisting

    sub order-drink($size, $flavor!) {
        say "$size $flavor, coming right up!";
    }

    order-drink('Large', 'Mountain Dew');    # OK
    order-drink('Small');                    # Error

=end programlisting

Required parameters must always appear at the beginning of a subroutine's
parameter list.

=head2 Named Arguments and Parameters

When a subroutine has many parameters, it can become difficult for the caller to
remember in what order they should pass the arguments. In this case, it is often
easier to pass the arguments by name. When you do so, the order in which they appear
does not matter:

=begin programlisting

    sub order-beer($type, $pints) {
        say ($pints == 1 ?? 'A pint' !! "$pints pints") ~ " of $type, please."
    }

    order-beer(type => 'Hobgoblin', pints => 1);
    # A pint of Hobgoblin, please.

    order-beer(pints => 3, type => 'Zlatý Bažant');
    # 3 pints of Zlatý Bažant, please.

=end programlisting

You may also specify that a parameter may only ever be passed an argument by
name (meaning that it is not allowed to pass it by position). To do this,
precede the name of the parameter with a colon:

=begin programlisting

    sub order-shrimps($count, :$from = 'Northern Sea') {
        say "I'd like $count pieces of shrimp from the $from, please";
    }

    order-shrimps(6);                       # takes 'Northern Sea'
    order-shrimps(4, from => 'Atlantic Ocean');
    order-shrimps(22, 'Mediterranean Sea'); # not allowed, :$from is named only

=end programlisting

Unlike positional parameters, named parameters are optional by default.
Append a C<!> to make a named parameter mandatory.

=begin programlisting

    sub design-ice-cream-mixture($base = 'Vanilla', :$name!) {
        say "Creating a new recipe named $name!"
    }

    design-ice-cream-mixture(name => 'Plain');
    design-ice-cream-mixture(base => 'Strawberry chip'); # error, missing $name

=end programlisting

=head3 Renaming Parameters

Since it is possible to pass arguments to parameters by name, the parameter
names should be considered as part of a subroutine's public API.  Choose them
carefully!  Sometimes it may be convenient to expose a parameter with one name
while binding to a variable of a different name:

=begin programlisting

    sub announce-time(:dinner($supper) = '8pm') {
        say "We eat dinner at $supper";
    }

    announce-time(dinner => '9pm');      # We eat dinner at 9pm

=end programlisting

Parameters can also have multiple names. If some of your users are British and
others are Americans, you might write:

=begin programlisting

    sub paint-rectangle(
            :$x      =   0,
            :$y      =   0,
            :$width  = 100,
            :$height =  50,
            :color(:colour($c))) {

       # print a piece of SVG that represents a rectangle
       say qq[<rect x="$x" y="$y" width="$width" height="$height"
                     style="fill: $c" />]
    }

    # both calls work the same
    paint-rectangle :color<Blue>;
    paint-rectangle :colour<Blue>;

    # of course you can still fill the other options
    paint-rectangle :width(30), :height(10), :colour<Blue>;

=end programlisting

=head3 Alternative Named Argument Syntaxes

=for author

This section is confusing.  I've tried to clarify.

=end for

Named arguments are actually C<Pair>s (of keys and values).  There are multiple
ways to write C<Pair>s.  The difference between the approaches is primarily one
of clarity, as each alternative provides a different quoting mechanism.  These
three calls all mean the same thing:

=begin programlisting

    announce-time(dinner => '9pm');
    announce-time(:dinner('9pm'));
    announce-time(:dinner<9pm>);

=end programlisting

If you're passing a boolean value, you may omit the value portion of the pair:

=begin programlisting

    toggle-blender( :enabled); # enables  the blender
    toggle-blender(:!enabled); # disables the blender

=end programlisting

A named argument of the form C<:name> with no value has an implicit value of
C<Bool::True>.  The negated form of this, C<:!name>, has an implicit value of
C<Bool::False>.

If you use a variable to create a pair, you can reuse the variable name as the
key of the pair.

=begin programlisting

    my $dinner = '9pm';
    announce-dinner :$dinner;  # same as dinner => $dinner;

=end programlisting

A<pair_forms> lists possible C<Pair> forms and their meanings.

=begin table C<Pair> forms and their meanings

Z<pair_forms>

=headrow

=row

=cell Shorthand

=cell Long form

=cell Description

=bodyrows

=row

=cell C<< :allowed >>

=cell C<< allowed => Bool::True >>

=cell Boolean flag

=row

=cell C<< :!allowed >>

=cell C<< allowed => Bool::False >>

=cell Boolean flag

=row

=cell C<< :bev<tea coffee> >>

=cell C<< bev => ('tea', 'coffee') >>

=cell List

=row

=cell C<< :times[1, 3] >>

=cell C<< times => [1, 3] >>

=cell Array

=row

=cell C<< :opts{ a => 2 } >>

=cell C<< opts => { a => 2 } >>

=cell Hash

=row

=cell C<< :$var >>

=cell C<< var => $var >>

=cell Scalar variable

=row

=cell C<< :@var >>

=cell C<< var => @var >>

=cell Array variable

=row

=cell C<< :%var >>

=cell C<< var => %var >>

=cell Hash variable

=row

=cell C<< :&var >>

=cell C<<  vaf => &var >>

=cell Callable/ Subroutine variable

=end table

You can use any of these forms in any context where you can use a C<Pair>
object. For example, when populating a hash:

=begin programlisting

    # TODO: better example
    my $black = 12;
    my %color-popularities = :$black, :blue(8),
                             red => 18, :white<0>;
    # same as
    # my %color-popularities =
    #       black => 12,
    #       blue  => 8,
    #       red   => 18,
    #       white => 0;

=end programlisting

Finally, to pass an existing C<Pair> object to a subroutine by position, not
name, either put it in parentheses (like C<(:$thing)>), or use the C<< => >>
operator with a quoted string on the left-hand side: C<< "thing" => $thing >>.

=head3 Order of Parameters

When both positional and named parameters are present in the same signature,
all the positional parameters need to come before the named parameters.

=begin programlisting

    sub mix(@ingredients, :$name)    { ... }    # OK
    sub notmix(:$name, @ingredients) { ... }    # Error

=end programlisting

Required positional parameters need to come before optional positional
parameters. However, named parameters have no such restriction.

=begin programlisting

    sub copy-machine($amount, $size = 'A4', :$color!, :$quality) { ... }    # OK
    sub fax-machine($amount = 1, $number)                        { ... }    # Error

=end programlisting

=head2 Slurpy Parameters

X<slurpy>

Sometimes, you may wish to allow a subroutine to receive any number of
arguments, and collect them all together into an array. In order to do
this, add an array parameter to the signature, placing the I<slurpy> prefix
(C<*>) before it.

=begin programlisting

    sub shout-them(*@words) {
        for @words -> $w {
            print uc("$w ");
        }
    }

    # now you can pass items
    shout-them('go');           # GO
    shout-them('go', 'home');   # GO HOME

=end programlisting

In addition to collecting all of the values, a slurpy parameter will also
flatten any arrays that it collects, so that you end up with a single, flat
list. Therefore:

=begin programlisting

    my @words = ('go', 'home');
    shout-them(@words);

=end programlisting

Will result in the C<*@words> parameter having two string elements, not just
a single array element.

You may choose to capture some arguments into positional parameters and leave
the rest to be captured by a slurpy array parameter. In this case, the slurpy
should come last. Similarly, C<*%hash> slurps all the remaining unbound named
arguments into a hash.

Slurpy arrays and hashes allow you to pass all positional and named arguments
to another routine:

=begin programlisting

    sub debug-wrapper(&code, *@positional, *%named) {
        warn "Calling '&code.name()' with arguments "
             ~ "@positional.perl(), %named.perl()\n";
        code(|@positional, |%named);
        warn "... back from '&code.name()'\n";
    }

    debug-wrapper(&order-shrimps, 4, from => 'Atlantic Ocean');

=end programlisting

=head1 Returning Results

Subroutines can also return values.  The ASCII art dancing example from earlier
in this chapter is simpler when each subroutine returns a new string:

=begin programlisting

    my %moves =
       hands-over-head => sub { return '/o\ '   },
       bird-arms       => sub { return '|/o\| ' },
       left            => sub { return '>o '    },
       right           => sub { return 'o< '    },
       arms-up         => sub { return '\o/ '   };

    my @awesome-dance = <arms-up bird-arms right hands-over-head>;

    for @awesome-dance -> $move {
        print %moves{$move}.();
    }

    print "\n";

=end programlisting

A subroutine can also return multiple values:

=begin programlisting

    sub menu {
        if rand < 0.5 {
            return ('fish', 'white wine')
        } else {
            return ('steak', 'red wine');
        }
    }

    my ($food, $beverage) = menu();

=end programlisting

X<return>

If you exclude the C<return> statement, then the value produced by the last
statement run inside the subroutine will be returned. This means that the
previous example may be simplified to:

=begin programlisting

    sub menu {
        if rand < 0.5 {
            'fish', 'white wine'
        } else {
            'steak', 'red wine';
        }
    }

    my ($food, $beverage) = menu();

=end programlisting

X<return, implicit>

Be wary of relying on this: when the flow of control within a subroutine is
sufficiently complex, adding an explicit C<return> will clarify the code. As a
general rule, only the simplest subroutines benefit from implicit C<return>.

C<return> has the additional effect of immediately exiting the subroutine:

=begin programlisting

    sub create-world(*%characteristics) {
        my $world = World.new(%characteristics);
        return $world if %characteristics<temporary>;

        save-world($world);
    }

=end programlisting

... and you'd better not misplace your new C<$world> if it's temporary, as it's
the only one you're going to get.

=head1 Return Types

X<return type>

Like most other modern programming languages, Perl 6 gives you the option of
explicitly specifying the return type of a subroutine. This allows you to
restrict the data type of the value returned from a subroutine. This is done
using the C<returns> trait:

=begin programlisting

    sub double-up($i) returns Int {
        return $i * 2;
    }

    my Int $ultimate-answer = double-up(21);    # 42

=end programlisting

Using the C<returns> trait is, of course, always optional. However, it may
allow the compiler to perform certain optimizations depending on which
Perl 6 implementation you are using.

=head1 Working With Types

Many subroutines cannot meaningfully work with arbitrary parameters, but
require that the parameters support certain methods or have other properties.
In these cases, it makes sense to restrict the types of parameters, such that
attempts to pass incorrect values as arguments will cause Perl to raise an
error at the time of calling the subroutine, or even at the compile time, if
the compiler is smart enough to catch thatN<at the time of writing, Rakudo
recognizes type mismatches for literals and explicitly typed variables>.

=head2 Basic Types

X<constraint, type>
X<parameter type constraint>

The easiest way to restrict the possible values that a subroutine accepts is by
writing a type name before a parameter.  For example, a subroutine that
performs numeric calculations on its parameters could require that its
arguments are of the type C<Numeric>:

=begin programlisting

    sub mean(Numeric $a, Numeric $b) {
        return ($a + $b) / 2;
    }

    say mean 2.5, 1.5;
    say mean 'some', 'strings';

=end programlisting

This produces the output:

=begin screen

    2
    Nominal type check failed for parameter '$a';
        expected Numeric but got Str instead

=end screen

X<type; nominal>
X<nominal type>

The I<nominal> type is an actual type name, here C<Numeric>, as opposed to a
type plus additional constraints, which are discussed in the next section.

If multiple parameters have type constraints, each argument must fulfill the
type constraint of the parameter to which it binds.

=head2 Adding Constraints

X<constraint>
X<where>

Sometimes a type name is insufficient to describe the requirements for an
argument. In this case, you may add an additional I<constraint> to the
parameter with a C<where> block:

=begin programlisting

    sub circle-radius-from-area(Real $area where { $area >= 0 }) {
        ($area / pi).sqrt
    }

    say circle-radius-from-area(3);    # OK
    say circle-radius-from-area(-3);   # Error

=end programlisting

Because the calculation is meaningful only for non-negative area values, the
parameter includes a constraint which returns C<True> for non-negative values.
If this constraint returns a false value, the type check will fail when
something calls this subroutineN<< note that the nominal type is now C<Real>
instead of C<Numeric>, because not all C<Numeric> values can be compared for
positiveness >>.

The block after the C<where> is optional; Perl performs the check by smart
matching the argument against whatever follows the C<where>. For example, it
is possible to accept arguments in a certain range by writing:

=begin programlisting

    sub set-volume(Numeric $volume where 0..11) {
        say "Turning it up to $volume";
    }

=end programlisting

Or one could constrain arguments to those that exist as keys of a hash:

=begin programlisting

    my %in-stock = 'Staropramen' => 8, 'Mori' => 5, 'La Trappe' => 9;

    sub order-beer(Str $name where %in-stock) {
        say "Here's your $name";
        %in-stock{$name}--;
        if %in-stock{$name} == 0 {
            say "OH NO! That was the last $name, folks! :'(";
            %in-stock.delete($name);
        }
    }

=end programlisting

=head1 Abstract and Concrete Parameters

TODO, XXX This section needs to be verified as accurate because even though it's
correct according to the spec, Rakudo seems to allow type objects
with :U.  Also, add examples for each adverb.

One of the Perl5-isms that Perl 6 eliminates is the need to verify the
"definedness" of a subroutine's arguments.

For example, the following Perl 5 code:

=begin programlisting

    sub foo {
        my $arg = shift;
        die "Argument is undefined" unless defined $arg;

        # Do something
    }

=end programlisting

can now be written as:

=begin programlisting

    sub foo(Int:D $arg) {
        # Do something
    }

=end programlisting

Notice the little smiley face attached to the parameter's type: C<:D>. This
adverb indicates that the given argument must be bound to a concrete object;
if not, a runtime exception will be thrown. That's why it's so happy!

By contrast, the C<:U> adverb can be used to indicate that the parameter
requires an undefined or I<abstract> object.

Additionally, the C<:_> adverb allows either defined or undefined values.
In practice, using C<:_> is a bit redundant.

Lastly, the C<:T> adverb can be used to indicate that the parameter may only
be given as a type object. For example:

=begin programlisting

    sub say-foobar(Int:T $arg) {
        say 'FOOBAR!';
    }

    say-foobar(Int);
    # FOOBAR!

=end programlisting

=head1 Captures

X<captures>
X<Capture>

Signatures are not just syntax; instead, they are first-class objects that
hold a list of C<Parameter> objects. Likewise, there is a data structure that
holds a collection of arguments, named a C<Capture>. Just as you rarely think
of a signature as a whole--instead focusing on individual parameters--you rarely
have to think about captures.  However, in some cases it is useful to do so, and
therefore Perl allows you to manipulate captures directly.

Captures have both positional and named parts which act like lists and hashes.
The list-like part contains the positional arguments and the hash-like parts
contains the named arguments.

=head2 Creating And Using A Capture

Whenever you write a sub-routine call, you are implicitly creating a C<Capture>.
However, it is immediately consumed by the call. Sometimes you may wish to make
a C<Capture>, store it and then later apply a subroutine--or multiple subroutines--
to the set of arguments it contains. To do this, use the C<\(...)> syntax.

=begin programlisting

    my @tasks = \(39, 3, action => { say $^a + $^b }),
                \(6, 7, action => { say $^a * $^b });

=end programlisting

Here, the C<@tasks> array will end up containing two C<Capture>s, each of
which contains two positional arguments and one named argument.

It doesn't matter where in the capture the named arguments appear, because
they are passed by name, not by position.

Like arrays and
hashes, a C<Capture> can be flattened into an argument list using C<|>:

=begin programlisting

    sub act($left, $right, :$action) {
        $action($left, $right);
    }

    for @tasks -> $task-args {
        act(|$task-args);
    }

=end programlisting

However, in this case it is specifying the full set of arguments for the
call, including both named and positional arguments.

Unlike signatures, captures work like references. Any variable mentioned in a
capture exists in the capture as a I<reference> to the variable.  Thus C<rw>
parameters still work with captures involved.

=begin programlisting

    my $value     = 7;
    my $to-change = \($value);

    sub double($x is rw) {
        $x *= 2;
    }

    sub triple($x is rw) {
        $x *= 3;
    }

    triple(|$to-change);
    double(|$to-change);

    say $value; # 42

=end programlisting

Perl types with both positional and named parts also show up in various other
situations. For example, regex matches have both positional and named
matches--C<Match> objects themselves are a type of capture. It's also possible
to conceive of an XML node type that is a type of capture, with named
attributes and positional children.  Binding this node to a function could use
the appropriate parameter syntax to work with various children and attributes.

=for author

I have the temptation to write "And this is a great way to implement the guts
of a compiler, as Perl 6 itself does!"

=end for

=head2 Captures In Signatures

All calls build a capture on the caller side and unpack it according to the
signature on the callee sideN<An optimizing Perl 6 compiler may, of course, be
able to optimize away part or all of this process, depending on what it knows
at compilation time.>. It is also possible to write a signature that binds the
capture itself into a variable. This is especially useful for writing routines
that delegate to other routines with the same arguments.

=begin programlisting

    sub visit-czechoslovakia(|$plan) {
        warn "Sorry, this country has been deprecated.";
        visit-slovakia(|$plan);
        visit-czech-republic(|$plan);
    }

=end programlisting

The benefit of using this over a signature like C<:(*@pos, *%named)> is that
these both enforce some context on the arguments, which may be premature. For
example, if the caller passes two arrays, they would flatten into C<@pos>. This
means that the two nested arrays could not be recovered at the point of
delegation. A capture preserves the two array arguments, so that the final
callee's signature may determine how to bind them.

=head1 Unpacking

Sometimes you need to work with only part of an array or a hash.  You can do
that with ordinary slicing access, or you can use signature binding:

=begin programlisting

    sub first-is-largest(@a) {
        my $first = @a.shift;
        # TODO: either explain junctions, or find a
        # concise way to write without them
        return $first >= all(@a);
    }

    # same thing:
    sub first-is-largest(@a) {
        my :($first, *@rest) := \(|@a)
        return $first >= all(@rest);
    }

=end programlisting

The signature binding approach might seem clumsy, but when you use it in the
main signature of a subroutine, you get tremendous power:

=begin programlisting

    sub first-is-largest([$first, *@rest]) {
        return $first >= all(@rest);
    }

=end programlisting

X<unpacking>
X<signature unpacking>
X<subsignature>

The brackets in the signature tell the compiler to expect a list-like argument.
Instead of binding to an array parameter, it instead I<unpacks> its arguments
into several parameters--in this case, a scalar for the first element and an
array for the rest.  This I<subsignature> also acts as a constraint on the
array parameter: the signature binding will fail unless the list in the capture
contains at least one item.

Likewise you can unpack a hash by using C<%(...)> instead of square brackets,
but you must access named parameters instead of positional.

=for author

Is this a little too cute?

=end for

=begin programlisting

    sub create-world(%(:$temporary, *%characteristics)) {
        my $world = World.new(%characteristics);
        return $world if $temporary;

        save-world($world);
    }

=end programlisting

# TODO: come up with a good example
# maybe steal something from http://jnthn.net/papers/2010-yapc-eu-signatures.pdf

# TODO: generic object unpacking

=head1 Currying

=for author

This explains some of the I<why> of currying, but not much of the I<what>.  Is
that necessary?  Also, I<currying> or I<partial application>?

=end for

Consider a module that provided the example from the "Optional Parameters"
section:

=begin programlisting

    sub order-burger( $type, $side? ) { ... };

=end programlisting

If you used C<order-burger> repeatedly, but often with a side of french fries,
you might wish that the author had also provided a C<order-burger-and-fries>
sub.  You could easily write it yourself:

=begin programlisting

    sub order-burger-and-fries ( $type ) {
        order-burger( $type, side => 'french fries' );
    }

=end programlisting

If your personal order is always vegetarian, you might instead wish for a
C<order-the-usual> sub. This is less concise to write, due to the optional
second parameter:

=begin programlisting

    sub order-the-usual ( $side? ) {
        if ( $side.defined ) {
            order-burger( 'veggie', $side );
        }
        else {
            order-burger( 'veggie' );
        }
    }

=end programlisting

Currying gives you a shortcut for these exact cases; it creates a new sub from
an existing sub, with parameters already filled in. In Perl 6, curry with the
C<.assuming> method:

=begin programlisting

    &order-the-usual        := &order-burger.assuming( 'veggie' );
    &order-burger-and-fries := &order-burger.assuming( side => 'french fries' );

=end programlisting

The new sub is like any other sub, and works with all the various
parameter-passing schemes already described.

=begin programlisting

    order-the-usual( 'salsa' );
    order-the-usual( side => 'broccoli' );

    order-burger-and-fries( 'plain' );
    order-burger-and-fries( :type<<double-beef>> );

=end programlisting

=head1 Introspection

Subroutines and their signatures are objects like any other. Besides calling
them, you can learn things about them, including the details of their
parameters:

=begin programlisting

    sub logarithm(Numeric $x, Numeric :$base = exp(1)) {
        log($x) / log($base);
    }

    my @params = &logarithm.signature.params;
    say @params.elems, ' parameters';

    for @params {
        say "Name:       ", .name;
        say "  Type:     ", .type;
        say "  named?    ", .named    ?? 'yes' !! 'no';
        say "  slurpy?   ", .slurpy   ?? 'yes' !! 'no';
        say "  optional? ", .optional ?? 'yes' !! 'no';
    }

=end programlisting

=begin screen

    2 parameters
    Name:       $x
      Type:     Numeric()
      named?    no
      slurpy?   no
      optional? no
    Name:       $base
      Type:     Numeric()
      named?    yes
      slurpy?   no
      optional? yes

=end screen

The C<&> sigil followed by a subroutine name gets the object representing that
subroutine. C<&logarithm.signature> returns the signature associated with the
subroutine, and calling C<.params> on the signature returns a list of
C<Parameter> objects. Each of these objects describes one parameter in detail.

=begin table Methods in the Parameter class

# stolen straight from S06, adapted a bit

=headrow

=row

=cell method

=cell description

=bodyrows

=row

=cell name

=cell The name of the lexical variable to bind to, if any

=row

=cell type

=cell The nominal type

=row

=cell constraints

=cell Any further type constraints

=row

=cell readonly

=cell True if the parameter has C<is readonly> trait

=row

=cell rw

=cell True if the parameter has C<is rw> trait

=row

=cell copy

=cell True if the parameter has C<is copy> trait

=row

=cell named

=cell True if the parameter is to be passed by name

=row

=cell named_names

=cell List of names a named parameter can be passed as

=row

=cell slurpy

=cell True if the parameter is slurpy

=row

=cell optional

=cell True if the parameter is optional

=row

=cell default

=cell A closure returning the default value

=row

=cell signature

=cell A nested signature to bind the argument against

=end table

# TODO: talk about &signature.cando once that's implemented

Signature introspection allows you to build interfaces that can obtain and then
pass the right data to a subroutine. For example, you could build a web form
generator that knew how to get input from a user, validate it, and then call a
routine with it based upon the information obtained through introspection.  A
similar approach might generate a command line interface along with some basic
usage instructions.

=for author

Link to traits section.

=end for

Beyond this, traits (L<traits>) allow you to associate extra data with
parameters.  This metadata can go far beyond that which subroutines,
signatures, and parameters normally provide.


=head1 The C<MAIN> Subroutine

Frequent users of the UNIX shells might have noticed a symmetry between
postional and named arguments to routines on the one hand, and argument
and options on the command line on the other hand.

This symmetry can be exploited by declaring a subroutine called C<MAIN>.
It is called every time the script is run, and its signature counts as
a specification for command line arguments.

=begin programlisting

    # script roll-dice.pl
    sub MAIN($count = 1, Numeric :$sides = 6, Bool :$sum) {
        my @numbers = (1..$sides).roll($count);
        say @numbers.join(' ');
        say "sum: ", [+] @numbers if $sum;
    }
    # TODO: explain ranges, .pick and [+]
    # (or reference later chapters)
    # note: [max] was already used in chapter 3, so [+] should
    #       make sense to the reader already.

=end programlisting

Calling this script without command line arguments leaves all three parameters
at their default values.

This is how some invocations could look like
N<<The use of random numbers through C<roll> means that you will likely see
different output if you try it.>>

=begin screen

    $ perl6 roll-dice.pl
    4
    $ perl6 roll-dice.pl 4
    1 4 2 4
    $ perl6 roll-dice.pl --sides=20 3
    18 1 2
    $ perl6 roll-dice.pl --sides=20 --sum 3
    9 14 12
    sum: 35
    $ perl6 roll-dice.pl --unknown-option
    Usage:
      roll-dice.pl [--sides=<Numeric>] [--sum] [<count>]

=end screen

Named arguments can be provided with the C<--name=value> syntax common to
many GNU tools, and positional arguments just by their value.

If an option does not require a parameter, the parameter in the MAIN
signature needs to be marked as being of C<Bool> type.

Usage of unknown options or too many or few arguments triggers an
automatically generated usage message, which can be overridden with a
custom C<USAGE> sub:

=begin programlisting

    sub MAIN(:$really-do-it!) { ... }
    sub USAGE() {
        say "This script is dangerous, please read the documentation first";
    }

=end programlisting

# TODO: maybe talk more about available options?

=for editor vim: se spell
